(function() {
    const sfxCache = {};
    const sfxToPreload = [
        'player-attack-hit', 'player-attack-miss', 'player-skillat-hit', 'player-skillat-miss',
        'player-skillheal-hit', 'player-skillheal-miss', 'monster-attack-hit', 'monster-attack-blocked',
        'monster-skillat-hit', 'monster-skillat-miss', 'monster-skillheal-hit', 'monster-skillheal-miss',
        'item-heal', 'item-damage'
    ];

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function preloadSounds() {
        sfxToPreload.forEach(soundName => {
            const audio = new Audio(`sfx/${soundName}.mp3`);
            audio.load();
            sfxCache[soundName] = audio;
        });
    }

    function playSound(soundName) {
        const audio = sfxCache[soundName];
        if (audio) {
            audio.currentTime = 0;
            audio.volume = 0.5;
            audio.play();
        } else {
            console.warn(`'${soundName}' Ìö®Í≥ºÏùåÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
        }
    }

    function shakeScreen() {
        gameContainer.classList.add('shake');
        gameContainer.addEventListener('animationend', () => {
            gameContainer.classList.remove('shake');
        }, { once: true });
    }

const battleModeContainer = document.querySelector('#battle-mode-container');
const gameContainer = battleModeContainer.querySelector('#game-container');
const monsterImageEl = gameContainer.querySelector('#monster-image');
const infoBtn = gameContainer.querySelector('#info-btn');
const monsterNameEl = gameContainer.querySelector('#monster-name');
const monsterHpBar = gameContainer.querySelector('#monster-hp-bar');
const playerNameEl = gameContainer.querySelector('#player-name');
const playerHpBar = gameContainer.querySelector('#player-hp-bar');
const playerMpBar = gameContainer.querySelector('#player-mp-bar');
const messageBox = gameContainer.querySelector('#message-box');
const messageTextEl = gameContainer.querySelector('#message-text');
const quizBox = gameContainer.querySelector('#quiz-box');
const quizTextPromptEl = gameContainer.querySelector('#quiz-text-prompt');
const quizTextContextEl = gameContainer.querySelector('#quiz-text-context');
const quizAnswersEl = gameContainer.querySelector('#quiz-answers');
const actionMenu = gameContainer.querySelector('#action-menu');
const actionButtons = gameContainer.querySelectorAll('.action-btn');

// üéØ ÏÉàÎ°úÏö¥ DOM ÏöîÏÜå Ï∂îÍ∞Ä
const turnIndicator = gameContainer.querySelector('#turn-indicator');
const progressBarFill = gameContainer.querySelector('#progress-bar-fill');
const progressText = gameContainer.querySelector('#progress-text');
const battleLog = gameContainer.querySelector('#battle-log');
const playerBox = gameContainer.querySelector('#player-box');
const monsterBox = gameContainer.querySelector('#monster-box');

const infoModal = battleModeContainer.querySelector('#info-modal');
const infoList = battleModeContainer.querySelector('#info-list');
const gameOverEl = battleModeContainer.querySelector('#game-over');
const dungeonClearEl = battleModeContainer.querySelector('#dungeon-clear');
const finalRewardsEl = battleModeContainer.querySelector('#final-rewards');
const returnToMainBtn = battleModeContainer.querySelector('#return-to-main-btn');
const modalBackdrop = battleModeContainer.querySelector('#modal-backdrop');
const skillModal = battleModeContainer.querySelector('#skill-modal');
const skillList = battleModeContainer.querySelector('#skill-list');
const itemModal = battleModeContainer.querySelector('#item-modal');
const itemList = battleModeContainer.querySelector('#item-list');
const victoryModal = battleModeContainer.querySelector('#victory-modal');
const victoryMessageEl = battleModeContainer.querySelector('#victory-message');
const continueBattleBtn = battleModeContainer.querySelector('#continue-battle-btn');
const gameOverMessageEl = battleModeContainer.querySelector('#game-over-message');
const returnToMainFromGameOverBtn = battleModeContainer.querySelector('#return-to-main-from-gameover-btn');

const cardDB = JSON.parse(localStorage.getItem('cardDB')) || [];
const skillDB = JSON.parse(localStorage.getItem('skillDB')) || [];
const itemDB = JSON.parse(localStorage.getItem('itemDB')) || [];
const monsterDB = JSON.parse(localStorage.getItem('monsterDB')) || [];
const dungeonDB = JSON.parse(localStorage.getItem('dungeonDB')) || [];
const questionDB = JSON.parse(localStorage.getItem('questionDB')) || [];
const userData = JSON.parse(localStorage.getItem('userData'));
const selectedDungeonId = localStorage.getItem('selectedDungeonId');

let player = {};
let monstersInDungeon = [];
let currentMonster;
let currentMonsterIndex = 0;
let dungeonRewards = { gold: 0, points: {} };
let turn = 'player';
let onQuizComplete = null;
let isActionInProgress = false;
let isReturningToMain = false;

// üéØ ÏÉàÎ°úÏö¥ Í∏∞Îä•: Ï†ÑÌà¨ Î°úÍ∑∏ Ï∂îÍ∞Ä Ìï®Ïàò
function addBattleLog(message, icon = '‚öîÔ∏è') {
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    logEntry.textContent = `${icon} ${message}`;
    
    battleLog.appendChild(logEntry);
    
    const logs = battleLog.querySelectorAll('.log-entry');
    if (logs.length > 10) {
        logs[0].remove();
    }
    
    battleLog.scrollTop = battleLog.scrollHeight;
}

// üéØ ÏÉàÎ°úÏö¥ Í∏∞Îä•: ÌÑ¥ ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
function updateTurnIndicator(currentTurn) {
    if (currentTurn === 'player') {
        turnIndicator.className = 'player-turn';
        turnIndicator.innerHTML = 'üó°Ô∏è ÎãπÏã†Ïùò ÌÑ¥ÏûÖÎãàÎã§';
        playerBox.classList.add('active-turn');
        monsterBox.classList.remove('active-turn');
    } else {
        turnIndicator.className = 'enemy-turn';
        turnIndicator.innerHTML = 'üëπ Î™¨Ïä§ÌÑ∞Ïùò ÌÑ¥ÏûÖÎãàÎã§';
        monsterBox.classList.add('active-turn');
        playerBox.classList.remove('active-turn');
    }
}

// üéØ ÏÉàÎ°úÏö¥ Í∏∞Îä•: ÏßÑÌñâÎèÑ Î∞î ÏóÖÎç∞Ïù¥Ìä∏
function updateProgressBar() {
    const currentIndex = currentMonsterIndex + 1;
    const totalMonsters = monstersInDungeon.length;
    const percentage = (currentIndex / totalMonsters) * 100;
    
    progressText.textContent = `Î™¨Ïä§ÌÑ∞ ${currentIndex} / ${totalMonsters}`;
    progressBarFill.style.width = `${percentage}%`;
}

function calculatePlayerStats() {
    const ownedCardCount = player.ownedCards.length;
    const collectionHpBonus = ownedCardCount * 1;
    const collectionMpBonus = Math.round(ownedCardCount * 0.5);
    const collectionAttackBonus = Math.round(ownedCardCount * 0.5);

    player.maxHp = player.baseHp + collectionHpBonus;
    player.maxMp = player.baseMp + collectionMpBonus;
    player.attack = player.baseAttack + collectionAttackBonus;

    player.equippedCards.forEach(cardId => {
        const card = cardDB.find(c => c.id === cardId);
        if (card) {
            player.maxHp += card.hpBonus;
            player.maxMp += card.mpBonus;
            player.attack += card.attackBonus;
        }
    });
}

function updateUI() {
    player.hp = Math.min(player.maxHp, player.hp);
    player.mp = Math.min(player.maxMp, player.mp);
    
    // ‚úÖ ÌîåÎ†àÏù¥Ïñ¥ HP Î∞î ÏóÖÎç∞Ïù¥Ìä∏
    const hpPercent = Math.round((player.hp / player.maxHp) * 100);
    playerHpBar.style.width = `${hpPercent}%`;
    document.getElementById('player-hp-text').textContent = `${player.hp} / ${player.maxHp}`;
    
    // ‚úÖ ÌîåÎ†àÏù¥Ïñ¥ MP Î∞î ÏóÖÎç∞Ïù¥Ìä∏
    const mpPercent = Math.round((player.mp / player.maxMp) * 100);
    playerMpBar.style.width = `${mpPercent}%`;
    document.getElementById('player-mp-text').textContent = `${player.mp} / ${player.maxMp}`;
    
    // ‚úÖ Î™¨Ïä§ÌÑ∞ HP Î∞î ÏóÖÎç∞Ïù¥Ìä∏
    const monsterHpPercent = Math.round((currentMonster.hp / currentMonster.maxHp) * 100);
    monsterHpBar.style.width = `${monsterHpPercent}%`;
    document.getElementById('monster-hp-text').textContent = `${currentMonster.hp} / ${currentMonster.maxHp}`;
}

function shuffleArray(array) { 
    for (let i = array.length - 1; i > 0; i--) { 
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    } 
    return array;
}

function showMessage(text, detailsOrCallback, callback) {
    messageBox.classList.remove('hidden');
    quizBox.classList.add('hidden');
    
    let explanation = '';
    let finalCallback = null;
    let isAfterQuiz = false;
    let isCorrect = false;
    
    if (typeof detailsOrCallback === 'function') {
        finalCallback = detailsOrCallback;
    } else if (typeof detailsOrCallback === 'object' && detailsOrCallback !== null) {
        isAfterQuiz = true;
        isCorrect = detailsOrCallback.isCorrect;
        explanation = detailsOrCallback.explanation || '';
        finalCallback = callback;
    } else if (detailsOrCallback === undefined && callback === undefined) {
        finalCallback = null;
    }
    
    let fullMessage = text;
    
    if (isAfterQuiz) {
        let answerHTML = '';
        let explanationHTML = '';

        if (currentQuestion && currentQuestion.correctAnswer) {
            if (isCorrect) {
                answerHTML = `<div style="margin-top: 15px; padding: 10px; background-color: rgba(76, 175, 80, 0.2); border-left: 3px solid var(--hp-color); text-align: left;"><strong>‚úîÔ∏è Ï†ïÎãµ:</strong> ${currentQuestion.correctAnswer}</div>`;
            } else {
                answerHTML = `<div style="margin-top: 15px; padding: 10px; background-color: rgba(199, 67, 67, 0.2); border-left: 3px solid #c74343; text-align: left;"><strong>‚ùå Ï†ïÎãµ:</strong> ${currentQuestion.correctAnswer}</div>`;
            }
        }
        
        if (explanation) {
            explanationHTML = `<div style="margin-top: 10px; padding: 10px; background-color: rgba(255,193,7,0.2); border-left: 3px solid var(--accent-color); text-align: left;"><strong>üí° Ìï¥ÏÑ§:</strong> ${explanation}</div>`;
        }
        
        fullMessage += `<br><br>${answerHTML}${explanationHTML}`;
    }
    
    messageTextEl.innerHTML = fullMessage;
    
    if (finalCallback) { 
        let waitTime = 1500;
        if (isAfterQuiz) {
            if (explanation) {
                waitTime = 3500;
            } else {
                waitTime = 2500; 
            }
        }
        setTimeout(finalCallback, waitTime);
    }
}

let currentQuestion = null;

function parseQuestion(questionString, questionType) {
    const parts = questionString.split('‚ä•');
    const questionData = { type: questionType };

    if (questionType === '1') {
        questionData.prompt = parts[0];
        questionData.context = parts[1];
        questionData.choices = [parts[2], parts[3], parts[4], parts[5]];
        const correctIndex = parseInt(parts[6], 10) - 1;
        if (correctIndex >= 0 && correctIndex < questionData.choices.length) {
            questionData.correctAnswer = questionData.choices[correctIndex];
        } else {
            questionData.correctAnswer = questionData.choices[0]; 
        }
        questionData.explanation = parts[7] || '';
    } else if (questionType === '2') {
        questionData.prompt = parts[0];
        questionData.context = parts[1];
        questionData.correctAnswer = parts[2];
        questionData.explanation = parts[3] || '';
    }
    
    return questionData;
}

function showQuiz(question, callback) {
    messageBox.classList.add('hidden');
    quizBox.classList.remove('hidden');
    onQuizComplete = callback;
    currentQuestion = question;

    const displayPrompt = question.prompt.replace(/@(.*?)@/g, '<u>$1</u>');
    const displayContext = question.context.replace(/@(.*?)@/g, '<u>$1</u>');
    
    quizTextPromptEl.innerHTML = displayPrompt;
    quizTextContextEl.innerHTML = displayContext;
    
    const quizAnswers = quizBox.querySelector('#quiz-answers');
    const shortAnswerArea = quizBox.querySelector('#quiz-short-answer-area');
    const shortAnswerInput = quizBox.querySelector('#short-answer-input');
    const shortAnswerSubmitBtn = quizBox.querySelector('#short-answer-submit-btn');

    if (question.type === '1') {
        quizAnswers.classList.remove('hidden');
        shortAnswerArea.classList.add('hidden');
        quizAnswers.innerHTML = '';
        
        const shuffledChoices = shuffleArray([...question.choices]);
        shuffledChoices.forEach(choice => {
            const button = document.createElement('button');
            button.className = 'quiz-btn';
            button.textContent = choice;
            button.onclick = () => handleQuizAnswer(choice === question.correctAnswer);
            quizAnswers.appendChild(button);
        });
    } else if (question.type === '2') {
        quizAnswers.classList.add('hidden');
        shortAnswerArea.classList.remove('hidden');
        
        shortAnswerInput.value = '';
        shortAnswerInput.disabled = false;
        shortAnswerInput.focus();
        
        shortAnswerSubmitBtn.disabled = false;
        
        const submitAnswer = () => {
            const userAnswer = shortAnswerInput.value.trim();
            const correctAnswer = question.correctAnswer;
            const normalizedUserAnswer = userAnswer.replace(/\s/g, '');
            const normalizedCorrectAnswer = correctAnswer.replace(/\s/g, '');
            handleQuizAnswer(normalizedUserAnswer === normalizedCorrectAnswer);
        };

        shortAnswerSubmitBtn.onclick = null;
        shortAnswerInput.onkeypress = null;
        shortAnswerSubmitBtn.onclick = submitAnswer;
        shortAnswerInput.onkeypress = (event) => {
            if (event.key === 'Enter') {
                submitAnswer();
            }
        };
    }
}

function handleQuizAnswer(isCorrect) {
    const quizAnswersButtons = quizAnswersEl.querySelectorAll('.quiz-btn');
    quizAnswersButtons.forEach(btn => btn.disabled = true);
    
    const shortAnswerInput = quizBox.querySelector('#short-answer-input');
    const shortAnswerSubmitBtn = quizBox.querySelector('#short-answer-submit-btn');
    if (shortAnswerInput) shortAnswerInput.disabled = true;
    if (shortAnswerSubmitBtn) shortAnswerSubmitBtn.disabled = true;
    
    if (onQuizComplete) { 
        onQuizComplete(isCorrect);
    }
}

function toggleActionMenu(enabled) { 
    actionButtons.forEach(btn => btn.disabled = !enabled); 
}

function setMonsterImage(state) {
    const imgBaseName = currentMonster.img || 'monster';
    monsterImageEl.src = `img/${imgBaseName}-${state}.png`;
}

function openModal(modal) { 
    modalBackdrop.classList.remove('hidden'); 
    modal.classList.remove('hidden'); 
}

function closeModal() { 
    modalBackdrop.classList.add('hidden'); 
    skillModal.classList.add('hidden'); 
    itemModal.classList.add('hidden'); 
    victoryModal.classList.add('hidden'); 
    infoModal.classList.add('hidden'); 
}

function generateMonsters() {
    const selectedDungeon = dungeonDB.find(d => d.id === selectedDungeonId);
    if (!selectedDungeon) { 
        console.error("ÏÑ†ÌÉùÎêú ÎçòÏ†Ñ Ï†ïÎ≥¥ ÏóÜÏùå:", selectedDungeonId); 
        monstersInDungeon = []; 
        return; 
    }
    const monsterIds = [
        selectedDungeon.monster1Id, selectedDungeon.monster2Id, selectedDungeon.monster3Id, 
        selectedDungeon.monster4Id, selectedDungeon.monster5Id
    ].filter(id => id);
    
    monstersInDungeon = monsterIds.map(id => {
        const monsterData = monsterDB.find(monster => monster.id === id);
        if (monsterData) {
            const questionsData = questionDB.find(q => q.id === monsterData.questionId);
            const newMonster = { ...monsterData };
            newMonster.usedQuestions = [];
            newMonster.questionCount = {};
            
            if (questionsData) {
                newMonster.questionSet = questionsData;
            } else {
                console.error(`Î™¨Ïä§ÌÑ∞ '${newMonster.name}'(ID: ${id})Ïóê ÎåÄÌïú Question DB(ID: ${newMonster.questionId})Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
                newMonster.questionSet = { type: '1', quizBank: [] };
            }
            return newMonster;
        }
        return null;
    }).filter(monster => monster);
}

function startPlayerTurn() {
    turn = 'player';
    setMonsterImage('idle');
    updateTurnIndicator('player');
    showMessage("ÎãπÏã†Ïùò ÌÑ¥ÏûÖÎãàÎã§.", () => {
        messageBox.classList.add('hidden');
        toggleActionMenu(true);
        isActionInProgress = false;
    });
}

function startEnemyTurn() {
    turn = 'enemy';
    toggleActionMenu(false);
    setMonsterImage('idle');
    updateTurnIndicator('enemy');
    showMessage("Î™¨Ïä§ÌÑ∞Ïùò ÌÑ¥ÏûÖÎãàÎã§.", () => {
        const randomKey = getRandomQuestion();
        if (!randomKey) {
            showMessage("Î™¨Ïä§ÌÑ∞Í∞Ä ÎÇº Î¨∏Ï†úÍ∞Ä ÏóÜÏñ¥ ÌñâÎèôÏùÑ ÌïòÏßÄ Î™ªÌï©ÎãàÎã§.", checkBattleEnd);
            return;
        }

        const rawQuestion = currentMonster.questionSet[randomKey];
        const questionType = currentMonster.questionSet.type;
        const question = parseQuestion(rawQuestion, questionType);
        const monsterSkills = [
            currentMonster.skillId1, currentMonster.skillId2, currentMonster.skillId3
        ].filter(id => id).map(id => skillDB.find(s => s.id === id))
         .filter(skill => skill && parseInt(currentMonster.mp) >= parseInt(skill.mpCost));
        
        const willUseSkill = monsterSkills.length > 0 && Math.random() < 0.5;
        
        if (willUseSkill) {
            const skillToUse = monsterSkills[Math.floor(Math.random() * monsterSkills.length)];
            currentMonster.mp -= parseInt(skillToUse.mpCost);
            showQuiz(question, async (isCorrect) => {
                if (isCorrect) {
                    setMonsterImage('hurt');
                    if (skillToUse.type == 1) {
                        playSound('monster-skillat-miss');
                        await sleep(200);
                        const damage = Math.floor(parseInt(currentMonster.attack) * parseFloat(skillToUse.effect));
                        const finalDamage = Math.floor(damage * 0.5);
                        player.hp = Math.max(0, player.hp - finalDamage);
                        addBattleLog(`Î∞©Ìï¥ ÏÑ±Í≥µ! ${skillToUse.name} Îç∞ÎØ∏ÏßÄ Í∞êÏÜå!`, 'üõ°Ô∏è');
                        showMessage(`Î∞©Ìï¥ ÏÑ±Í≥µ! Î™¨Ïä§ÌÑ∞Ïùò ${skillToUse.name} Îç∞ÎØ∏ÏßÄÍ∞Ä ${finalDamage}Î°ú Í∞êÏÜå!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
                    } else if (skillToUse.type == 2) {
                        playSound('monster-skillheal-miss');
                        await sleep(200);
                        const healAmount = Math.floor(parseInt(skillToUse.effect) * 0.5);
                        currentMonster.hp = Math.min(currentMonster.maxHp, currentMonster.hp + healAmount);
                        addBattleLog(`Î∞©Ìï¥ ÏÑ±Í≥µ! ${skillToUse.name} ÌöåÎ≥µÎüâ Í∞êÏÜå!`, 'üõ°Ô∏è');
                        showMessage(`Î∞©Ìï¥ ÏÑ±Í≥µ! Î™¨Ïä§ÌÑ∞Í∞Ä ${skillToUse.name}ÏúºÎ°ú HPÎ•º ${healAmount}Îßå ÌöåÎ≥µ!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
                    }
                } else {
                    setMonsterImage('happy');
                    if (skillToUse.type == 1) {
                        playSound('monster-skillat-hit');
                        await sleep(200);
                        shakeScreen();
                        const damage = Math.floor(parseInt(currentMonster.attack) * parseFloat(skillToUse.effect));
                        const finalDamage = damage;
                        player.hp = Math.max(0, player.hp - finalDamage);
                        addBattleLog(`${skillToUse.name}! ${finalDamage} Îç∞ÎØ∏ÏßÄ!`, 'üí•');
                        showMessage(`Î™¨Ïä§ÌÑ∞Ïùò ${skillToUse.name}! ${finalDamage}Ïùò Îç∞ÎØ∏ÏßÄ!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
                    } else if (skillToUse.type == 2) {
                        playSound('monster-skillheal-hit');
                        await sleep(200);
                        const healAmount = parseInt(skillToUse.effect);
                        currentMonster.hp = Math.min(currentMonster.maxHp, currentMonster.hp + healAmount);
                        addBattleLog(`${skillToUse.name}! HP ${healAmount} ÌöåÎ≥µ!`, 'üíö');
                        showMessage(`Î™¨Ïä§ÌÑ∞Í∞Ä ${skillToUse.name}ÏúºÎ°ú HPÎ•º ${healAmount} ÌöåÎ≥µ!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
                    }
                }
                updateUI();
            });
        } else {
            enemyBasicAttack(question);
        }
    });
}

function enemyBasicAttack(question) {
    showQuiz(question, async (isCorrect) => {
        if (isCorrect) {
            playSound('monster-attack-blocked');
            await sleep(200);
            setMonsterImage('hurt');
            const reducedDamage = Math.floor(parseInt(currentMonster.attack) * 0.5);
            player.hp = Math.max(0, player.hp - reducedDamage);
            updateUI();
            addBattleLog(`Î∞©Ïñ¥ ÏÑ±Í≥µ! ${reducedDamage}Ïùò Îç∞ÎØ∏ÏßÄ!`, 'üõ°Ô∏è');
            showMessage(`Î∞©Ïñ¥ ÏÑ±Í≥µ! ${reducedDamage}Ïùò Îç∞ÎØ∏ÏßÄÎ•º Î∞õÏïòÎã§!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
        } else {
            playSound('monster-attack-hit');
            await sleep(200);
            setMonsterImage('happy');
            shakeScreen();
            player.hp = Math.max(0, player.hp - parseInt(currentMonster.attack));
            updateUI();
            addBattleLog(`Î∞©Ïñ¥ Ïã§Ìå®! ${currentMonster.attack}Ïùò Îç∞ÎØ∏ÏßÄ!`, 'üí•');
            showMessage(`Î∞©Ïñ¥ Ïã§Ìå®! ${currentMonster.attack}Ïùò Îç∞ÎØ∏ÏßÄÎ•º Î∞õÏïòÎã§!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
        }
    });
}

function getRandomQuestion() {
    const questionSet = currentMonster.questionSet;
    const allQuestionKeys = Object.keys(questionSet)
        .filter(k => k.startsWith('question') && questionSet[k]);
    
    if (allQuestionKeys.length === 0) {
        console.error("ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î¨∏Ï†úÍ∞Ä ÏóÜÏäµÎãàÎã§!");
        return null;
    }
    
    const availableQuestions = allQuestionKeys.filter(
        key => !currentMonster.usedQuestions.includes(key)
    );
    
    if (availableQuestions.length === 0) {
        currentMonster.usedQuestions = [];
        return getRandomQuestion();
    }
    
    const randomKey = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
    currentMonster.usedQuestions.push(randomKey);
    
    if (!currentMonster.questionCount[randomKey]) {
        currentMonster.questionCount[randomKey] = 0;
    }
    currentMonster.questionCount[randomKey]++;

    return randomKey;
}

function handleAction(action) {
    if (turn !== 'player' || isActionInProgress) return;
    isActionInProgress = true;
    toggleActionMenu(false);

    if (action === 'skill') {
        openSkillMenu();
        return;
    }
    if (action === 'item') {
        openItemMenu();
        return;
    }

    const randomKey = getRandomQuestion();
    if (!randomKey) {
        showMessage("Î™¨Ïä§ÌÑ∞Í∞Ä ÎÇº Î¨∏Ï†úÍ∞Ä ÏóÜÏäµÎãàÎã§! (DB ÌôïÏù∏ ÌïÑÏöî)", () => { startPlayerTurn(); });
        return;
    }
    const rawQuestion = currentMonster.questionSet[randomKey];
    const questionType = currentMonster.questionSet.type;
    const question = parseQuestion(rawQuestion, questionType);

    switch(action) {
        case 'attack':
            showQuiz(question, async (isCorrect) => {
                if (isCorrect) {
                    playSound('player-attack-hit');
                    await sleep(200);
                    shakeScreen();
                    setMonsterImage('hurt');
                    currentMonster.hp = Math.max(0, currentMonster.hp - player.attack);
                    updateUI();
                    addBattleLog(`Í≥µÍ≤© ÏÑ±Í≥µ! ${player.attack}Ïùò Îç∞ÎØ∏ÏßÄ!`, '‚öîÔ∏è');
                    showMessage(`Í≥µÍ≤© ÏÑ±Í≥µ! ${player.attack}Ïùò Îç∞ÎØ∏ÏßÄ!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
                } else { 
                    playSound('player-attack-miss');
                    await sleep(200);
                    setMonsterImage('happy');
                    addBattleLog('Í≥µÍ≤©Ïù¥ ÎπóÎÇòÍ∞îÎã§...', '‚ùå');
                    showMessage("Í≥µÍ≤©Ïù¥ ÎπóÎÇòÍ∞îÎã§...", { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd); 
                }
            });
            break;
        case 'skill': openSkillMenu(); break;
        case 'item': openItemMenu(); break;
        case 'flee':
            showQuiz(question, (isCorrect) => {
                if (isCorrect && Math.random() < 0.5) {
                    showMessage("ÎèÑÎßùÏπòÎäîÎç∞ ÏÑ±Í≥µÌñàÎã§!", () => { 
                        if (window.endBattle) {
                            window.endBattle();
                        }
                    });
                } else { 
                    showMessage("ÎèÑÎßùÏπ† Ïàò ÏóÜÏóàÎã§...", { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd); 
                }
            });
            break;
    }
}

function checkBattleEnd() {
    updateUI();
    if (player.hp <= 0) {
        const penaltyRate = (Math.floor(Math.random() * 10) + 1) / 100;
        const goldPenalty = Math.floor(player.gold * penaltyRate);
        
        let pointsPenalty = 0;
        let pointTypeKey = '';
        let pointTypeName = '';

        if (currentMonster.affiliation === 'ÌíàÏÇ¨') {
            pointTypeKey = 'partsOfSpeech';
            pointTypeName = 'ÌíàÏÇ¨';
        } else if (currentMonster.affiliation === 'Î¨∏Ïû• ÏÑ±Î∂Ñ') {
            pointTypeKey = 'sentenceComponents';
            pointTypeName = 'Î¨∏Ïû• ÏÑ±Î∂Ñ';
        }

        if (pointTypeKey && player.points[pointTypeKey] > 0) {
            pointsPenalty = Math.floor(player.points[pointTypeKey] * penaltyRate);
            player.points[pointTypeKey] -= pointsPenalty;
        }
        player.gold -= goldPenalty;

        let finalUserData = JSON.parse(localStorage.getItem('userData'));
        finalUserData.gold = player.gold;
        finalUserData.points = player.points;
        localStorage.setItem('userData', JSON.stringify(finalUserData));
        if (finalUserData.id) {
            uploadUserData(finalUserData.id);
        }

        let penaltyMessage = `Ï†ÑÌà¨ÏóêÏÑú Ìå®Î∞∞ÌïòÏó¨ Í≥®Îìú ${goldPenalty} G`;
        if (pointsPenalty > 0) {
            penaltyMessage += `ÏôÄ ${pointTypeName} Ìè¨Ïù∏Ìä∏ ${pointsPenalty} P`;
        }
        penaltyMessage += 'Î•º ÏûÉÏóàÏäµÎãàÎã§.';
        gameOverMessageEl.textContent = penaltyMessage;
        
        gameOverEl.classList.remove('hidden'); 
        return;
    }
    
    if (currentMonster.hp <= 0) {
        const goldReward = parseInt(currentMonster.goldReward, 10) || 0;
        const pointReward = parseInt(currentMonster.pointReward, 10) || 0;
        dungeonRewards.gold += goldReward;

        let pointTypeKey = '';
        let pointTypeName = '';

        if (currentMonster.affiliation === 'ÌíàÏÇ¨') {
            pointTypeKey = 'partsOfSpeech';
            pointTypeName = 'ÌíàÏÇ¨';
        } else if (currentMonster.affiliation === 'Î¨∏Ïû• ÏÑ±Î∂Ñ') {
            pointTypeKey = 'sentenceComponents';
            pointTypeName = 'Î¨∏Ïû• ÏÑ±Î∂Ñ';
        }

        if (pointTypeKey) {
            if (!dungeonRewards.points[pointTypeKey]) {
                dungeonRewards.points[pointTypeKey] = 0;
            }
            dungeonRewards.points[pointTypeKey] += pointReward;
        }

        const rewardText = `Î≥¥ÏÉÅÏúºÎ°ú ${goldReward} Í≥®ÎìúÏôÄ ${pointTypeName} Ìè¨Ïù∏Ìä∏ ${pointReward} PÎ•º ÌöçÎìùÌñàÎã§!`;
        victoryMessageEl.innerHTML = `${currentMonster.name}Î•º Ïì∞Îü¨Ìä∏Î†∏Îã§!<br>${rewardText}`;
        openModal(victoryModal);
        return;
    }
    
    if (turn === 'player') startEnemyTurn();
    else startPlayerTurn();
}

function openSkillMenu() {
    skillList.innerHTML = '';
    player.equippedCards.forEach(cardId => {
        const card = cardDB.find(c => c.id === cardId);
        if (!card || !card.skillId) return;
        const skill = skillDB.find(s => s.id === card.skillId);
        if(!skill) return;
        const button = document.createElement('button');
        button.className = 'menu-item-btn';
        button.innerHTML = `${skill.name} <span class="item-quantity">MP ${skill.mpCost}</span><br><small>${skill.desc}</small>`;
        button.disabled = player.mp < skill.mpCost;
        button.onclick = () => useSkill(skill);
        skillList.appendChild(button);
    });
    openModal(skillModal);
}

function useSkill(skill) {
    closeModal();
    isActionInProgress = true;
    const randomKey = getRandomQuestion();
    if (!randomKey) {
        showMessage("Î™¨Ïä§ÌÑ∞Í∞Ä ÎÇº Î¨∏Ï†úÍ∞Ä ÏóÜÏäµÎãàÎã§!", () => { startPlayerTurn(); });
        return;
    }
    const rawQuestion = currentMonster.questionSet[randomKey];
    const questionType = currentMonster.questionSet.type;
    const question = parseQuestion(rawQuestion, questionType);
    showQuiz(question, async (isCorrect) => {
        player.mp -= skill.mpCost;
        if (isCorrect) {
            setMonsterImage('hurt');
            if (skill.type === 1) {
                playSound('player-skillat-hit');
                await sleep(200);
                shakeScreen();
                const damage = Math.floor(player.attack * skill.effect);
                currentMonster.hp = Math.max(0, currentMonster.hp - damage);
                addBattleLog(`${skill.name} Î∞úÎèô! ${damage} Îç∞ÎØ∏ÏßÄ!`, '‚ú®');
                showMessage(`${skill.name} Î∞úÎèô! ${damage}Ïùò Îç∞ÎØ∏ÏßÄ!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
            } else if (skill.type === 2) {
                playSound('player-skillheal-hit');
                await sleep(200);
                player.hp = Math.min(player.maxHp, player.hp + skill.effect);
                addBattleLog(`${skill.name} Î∞úÎèô! HP ${skill.effect} ÌöåÎ≥µ!`, 'üíö');
                showMessage(`${skill.name} Î∞úÎèô! HPÎ•º ${skill.effect} ÌöåÎ≥µÌñàÎã§!`, { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
            }
        } else {
            setMonsterImage('happy');
            if (skill.type === 1){
                playSound('player-skillat-miss');
                await sleep(200);
            } else if (skill.type ===2){
                playSound('player-skillheal-miss');
                await sleep(200);
            }
            addBattleLog('Ïä§ÌÇ¨ Î∞úÎèô Ïã§Ìå®...', '‚ùå');
            showMessage("Ïä§ÌÇ¨ Î∞úÎèôÏóê Ïã§Ìå®ÌñàÎã§...", { isCorrect: isCorrect, explanation: currentQuestion.explanation }, checkBattleEnd);
        }
        updateUI();
    });
}

function openItemMenu() {
    const usableItems = Object.keys(player.inventory).filter(key => player.inventory[key] > 0);
    if (usableItems.length === 0) {
        showMessage("ÏÇ¨Ïö©Ìï† ÏïÑÏù¥ÌÖúÏù¥ ÏóÜÏäµÎãàÎã§.");
        setTimeout(() => { 
            toggleActionMenu(true); 
            isActionInProgress = false;
        }, 1500);
        return;
    }
    itemList.innerHTML = '';
    usableItems.forEach(key => {
        const item = itemDB.find(i => i.id === key);
        if (!item) return;
        const quantity = player.inventory[key];
        const button = document.createElement('button');
        button.className = 'menu-item-btn';
        button.innerHTML = `${item.name} <span class="item-quantity">x${quantity}</span><br><small>${item.desc}</small>`;
        button.onclick = () => useItem(item);
        itemList.appendChild(button);
    });
    openModal(itemModal);
}

async function useItem(item) {
    closeModal();
    isActionInProgress = true;
    player.inventory[item.id]--;
    if (item.type === 1) {
        playSound('item-heal');
        await sleep(200);
        player.hp = Math.min(player.maxHp, player.hp + item.value);
        addBattleLog(`${item.name} ÏÇ¨Ïö©! HP ${item.value} ÌöåÎ≥µ!`, 'üíä');
    } else if (item.type === 2) {
        playSound('item-heal');
        await sleep(200);
        player.mp = Math.min(player.maxMp, player.mp + item.value);
        addBattleLog(`${item.name} ÏÇ¨Ïö©! MP ${item.value} ÌöåÎ≥µ!`, 'üíä');
    } else if (item.type === 3) {
        playSound('item-damage');
        await sleep(200);
        setMonsterImage('hurt');
        currentMonster.hp = Math.max(0, currentMonster.hp - item.value);
        shakeScreen();
        addBattleLog(`${item.name} ÏÇ¨Ïö©! ${item.value} Îç∞ÎØ∏ÏßÄ!`, 'üí£');
    }
    updateUI();
    showMessage(`${item.name}ÏùÑ(Î•º) ÏÇ¨Ïö©ÌñàÎã§!`, checkBattleEnd);
}

function initGame() {
    preloadSounds();

    if (!userData) {
        alert("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§. Î©îÏù∏ ÌôîÎ©¥ÏúºÎ°ú ÎèåÏïÑÍ∞ëÎãàÎã§.");
        window.location.href = 'main.html';
        return;
    }
    
    player = { 
        name: userData.nickname || 'Ïö©ÏÇ¨',
        baseHp: userData.baseHp || 80,
        baseMp: userData.baseMp || 50,
        baseAttack: userData.baseAttack || 15,
        ownedCards: userData.ownedCards || [],
        equippedCards: userData.equippedCards || [],
        inventory: userData.inventory || {},
        gold: userData.gold || 0,
        points: userData.points || { partsOfSpeech: 0, sentenceComponents: 0 }
    };
    
    calculatePlayerStats();

    const playerImageEl = gameContainer.querySelector('#player-image');
    let conditionsMet = 0;
    if (player.maxHp >= 50) conditionsMet++;
    if (player.maxHp >= 80) conditionsMet++;
    if (player.maxHp >= 160) conditionsMet++;
    if (player.maxHp >= 250) conditionsMet++;
    if (player.maxHp >= 350) conditionsMet++;
    if (player.maxHp >= 500) conditionsMet++;
    if (player.maxMp >= 50) conditionsMet++;
    if (player.maxMp >= 80) conditionsMet++;
    if (player.maxMp >= 160) conditionsMet++;
    if (player.maxMp >= 250) conditionsMet++;
    if (player.maxMp >= 350) conditionsMet++;
    if (player.maxMp >= 500) conditionsMet++;
    if (player.attack >= 30) conditionsMet++;
    if (player.attack >= 45) conditionsMet++;
    if (player.attack >= 70) conditionsMet++;
    if (player.attack >= 100) conditionsMet++;
    if (player.attack >= 150) conditionsMet++;
    if (player.attack >= 220) conditionsMet++;
    
    playerImageEl.src = `img/player${conditionsMet}.png`;

    player.hp = player.maxHp;
    player.mp = player.maxMp;

    currentMonsterIndex = 0;
    generateMonsters();
    
    if (monstersInDungeon.length === 0) {
        messageTextEl.textContent = "ÎçòÏ†ÑÏóê Ï∂úÌòÑÌï† Î™¨Ïä§ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§!";
        toggleActionMenu(false);
        return;
    }
    
    const setupMonster = (monsterData) => {
        const newMonster = { ...monsterData };
        newMonster.maxHp = parseInt(newMonster.hp, 10) || 50;
        newMonster.hp = newMonster.maxHp;
        newMonster.mp = parseInt(newMonster.mp, 10) || 10;
        return newMonster;
    };
    currentMonster = setupMonster(monstersInDungeon[currentMonsterIndex]);
     
    playerNameEl.textContent = player.name;
    monsterNameEl.textContent = currentMonster.name;
    
    isActionInProgress = true;
    toggleActionMenu(false);

    actionButtons.forEach(btn => btn.addEventListener('click', () => handleAction(btn.dataset.action)));
    document.querySelectorAll('.modal-close-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
            // ÎÇ¥ Ï†ïÎ≥¥ Î™®Îã¨Ïùò Îã´Í∏∞ Î≤ÑÌäºÏù∏ÏßÄ ÌôïÏù∏
            const isInfoModalClose = event.target.closest('#info-modal');
            
            closeModal();
            
            // ÎÇ¥ Ï†ïÎ≥¥ Î™®Îã¨Ïù¥ ÏïÑÎãê ÎïåÎßå Ïï°ÏÖò Î©îÎâ¥ ÌôúÏÑ±Ìôî
            if (!isInfoModalClose) {
                isActionInProgress = false;
                toggleActionMenu(true);
            }
        });
    });
    
    continueBattleBtn.addEventListener('click', () => {
        closeModal();
        currentMonsterIndex++;
        if (currentMonsterIndex >= monstersInDungeon.length) {
            let rewardsHTML = `<p>üí∞ Í≥®Îìú: ${dungeonRewards.gold} G</p>`;
            const pointTypeNames = {
                partsOfSpeech: 'ÌíàÏÇ¨ Ìè¨Ïù∏Ìä∏',
                sentenceComponents: 'Î¨∏Ïû• ÏÑ±Î∂Ñ Ìè¨Ïù∏Ìä∏'
            };
            for (const pointType in dungeonRewards.points) {
                const pointAmount = dungeonRewards.points[pointType];
                if (pointAmount > 0) {
                    const pointName = pointTypeNames[pointType] || pointType;
                    rewardsHTML += `<p>üÖøÔ∏è ${pointName}: ${pointAmount} P</p>`;
                }
            }
            finalRewardsEl.innerHTML = rewardsHTML;
            dungeonClearEl.classList.remove('hidden');
        } else {
            currentMonster = setupMonster(monstersInDungeon[currentMonsterIndex]);
            monsterNameEl.textContent = currentMonster.name;
            updateProgressBar();
            addBattleLog(`${currentMonster.name} Îì±Ïû•!`, 'üëπ');
            updateUI();
            startPlayerTurn();
        }
    });
    
    returnToMainBtn.addEventListener('click', async () => {
        if (isReturningToMain) return;
        isReturningToMain = true;
        returnToMainBtn.disabled = true;

        try {
            const finalUserData = JSON.parse(localStorage.getItem('userData'));
            finalUserData.gold += dungeonRewards.gold;
            if (!finalUserData.points) {
                finalUserData.points = {};
            }
            for (const pointType in dungeonRewards.points) {
                if (!finalUserData.points[pointType]) {
                    finalUserData.points[pointType] = 0;
                }
                finalUserData.points[pointType] += dungeonRewards.points[pointType];
            }
            finalUserData.inventory = player.inventory;
            localStorage.setItem('userData', JSON.stringify(finalUserData));
            
            if (finalUserData.id) {
                await uploadUserData(finalUserData.id);
            } else {
                console.error("Ï†ÄÏû•Ìï† ÏÇ¨Ïö©Ïûê IDÍ∞Ä ÏóÜÏäµÎãàÎã§.");
            }
        } catch (error) {
            console.error("Î≥¥ÏÉÅ Ï†ÄÏû• Ï§ë Ïò§Î•ò Î∞úÏÉù:", error);
        } finally {
            if (window.endBattle) {
                window.endBattle();
            }
        }
    });

    returnToMainFromGameOverBtn.addEventListener('click', () => {
        if (window.endBattle) {
            window.endBattle();
        }
    });

    infoBtn.addEventListener('click', () => {
        const ownedCardCount = player.ownedCards.length;
        const collectionAttackBonus = Math.round(ownedCardCount * 0.5);
        const collectionHpBonus = ownedCardCount * 1;
        const collectionMpBonus = Math.round(ownedCardCount * 0.5);
        const equippedAttackBonus = player.attack - player.baseAttack - collectionAttackBonus;
        const equippedHpBonus = player.maxHp - player.baseHp - collectionHpBonus;
        const equippedMpBonus = player.maxMp - player.baseMp - collectionMpBonus;

        // ‚úÖ (5) Ïû•Ï∞© Ïπ¥Îìú Î™©Î°ù HTML ÏÉùÏÑ±
        let equippedCardsHTML = '';
        if (player.equippedCards.length === 0) {
            equippedCardsHTML = '<div class="empty-state">Ïû•Ï∞©Îêú Ïπ¥ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§</div>';
        } else {
            equippedCardsHTML = '<div class="card-list">';
            player.equippedCards.forEach(cardId => {
                const card = cardDB.find(c => c.id === cardId);
                if (card) {
                    equippedCardsHTML += `<div class="card-tag">${card.name}</div>`;
                }
            });
            equippedCardsHTML += '</div>';
        }

        // ‚úÖ (5) Íµ¨Ï°∞ÌôîÎêú Ï†ïÎ≥¥ ÌëúÏãú
        infoList.innerHTML = `
            <div class="info-section">
                <div class="section-title">‚öîÔ∏è Ï†ÑÌà¨ Îä•Î†•Ïπò</div>
                <div class="info-row">
                    <span class="info-label">ÏµúÎåÄ HP</span>
                    <span class="info-value">${player.maxHp}</span>
                </div>
                <div class="info-row" style="font-size: 0.85em; color: #999; padding-left: 20px; padding-top: 0;">
                    <span>Í∏∞Î≥∏ ${player.baseHp} + ÎèÑÍ∞ê ${collectionHpBonus} + Ïû•Ï∞© ${equippedHpBonus}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">ÏµúÎåÄ MP</span>
                    <span class="info-value">${player.maxMp}</span>
                </div>
                <div class="info-row" style="font-size: 0.85em; color: #999; padding-left: 20px; padding-top: 0;">
                    <span>Í∏∞Î≥∏ ${player.baseMp} + ÎèÑÍ∞ê ${collectionMpBonus} + Ïû•Ï∞© ${equippedMpBonus}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Í≥µÍ≤©Î†•</span>
                    <span class="info-value">${player.attack}</span>
                </div>
                <div class="info-row" style="font-size: 0.85em; color: #999; padding-left: 20px; padding-top: 0;">
                    <span>Í∏∞Î≥∏ ${player.baseAttack} + ÎèÑÍ∞ê ${collectionAttackBonus} + Ïû•Ï∞© ${equippedAttackBonus}</span>
                </div>
            </div>

            <div class="info-section">
                <div class="section-title">üí∞ Î≥¥Ïú† ÏûêÏõê</div>
                <div class="info-row">
                    <span class="info-label">Í≥®Îìú</span>
                    <span class="info-value">${player.gold} G</span>
                </div>
                <div class="info-row">
                    <span class="info-label">ÌíàÏÇ¨ Ìè¨Ïù∏Ìä∏</span>
                    <span class="info-value">${player.points.partsOfSpeech || 0} P</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Î¨∏Ïû• ÏÑ±Î∂Ñ Ìè¨Ïù∏Ìä∏</span>
                    <span class="info-value">${player.points.sentenceComponents || 0} P</span>
                </div>
            </div>

            <div class="info-section">
                <div class="section-title">üé¥ Ïû•Ï∞© Ïπ¥Îìú (${player.equippedCards.length}/4)</div>
                ${equippedCardsHTML}
            </div>

            <div class="info-section">
                <div class="section-title">üìä Ïª¨Î†âÏÖò</div>
                <div class="info-row">
                    <span class="info-label">Î≥¥Ïú† Ïπ¥Îìú Ïàò</span>
                    <span class="info-value">${ownedCardCount}Ïû•</span>
                </div>
            </div>
        `;
        
        openModal(infoModal);
    });
    
    updateProgressBar();
    updateUI();
    startPlayerTurn();
}

initGame();

function runRandomTest(questionId, iterations = 100) {
    const questionSet = questionDB.find(q => q.id === questionId);
    if (!questionSet) {
        console.error(`'${questionId}' IDÎ•º Í∞ÄÏßÑ Î¨∏Ï†ú ÏÑ∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
        return;
    }

    const questionKeys = Object.keys(questionSet).filter(k => k.startsWith('question') && questionSet[k]);
    if (questionKeys.length === 0) {
        console.error(`'${questionId}' Î¨∏Ï†ú ÏÑ∏Ìä∏Ïóê Ïú†Ìö®Ìïú Î¨∏Ï†úÍ∞Ä ÏóÜÏäµÎãàÎã§.`);
        return;
    }

    console.log(`--- Î¨¥ÏûëÏúÑ Ï∂îÏ∂ú ÌÖåÏä§Ìä∏ ÏãúÏûë (Ï¥ù ${iterations}Ìöå) ---`);
    console.log(`ÌÖåÏä§Ìä∏ ÎåÄÏÉÅ: ${questionId} (Ïú†Ìö® Î¨∏Ìï≠ Ïàò: ${questionKeys.length}Í∞ú)`);
    
    const results = {};
    questionKeys.forEach(key => { results[key] = 0; });

    for (let i = 0; i < iterations; i++) {
        const randomKey = questionKeys[Math.floor(Math.random() * questionKeys.length)];
        results[randomKey]++;
    }

    console.log("--- ÌÖåÏä§Ìä∏ Í≤∞Í≥º ---");
    console.log("Í∞Å Î¨∏Ï†úÍ∞Ä ÏÑ†ÌÉùÎêú ÌöüÏàò:");
    console.table(results);
}

window.runRandomTest = runRandomTest;
})();